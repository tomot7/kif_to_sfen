<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIF to SFEN 変換ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', 'Inter', sans-serif;
        }
        .custom-button {
            transition: all 0.2s ease-in-out;
        }
        .custom-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900 dark:text-white">KIF to SFEN 変換ツール</h1>
            <p class="mt-2 text-gray-600 dark:text-gray-400">KIF形式の棋譜ファイルをアップロードし、各手の局面をSFEN形式で表示します。</p>
        </header>

        <main class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 md:p-8">
            <div class="mb-6">
                <label class="block mb-2 text-lg font-medium text-gray-700 dark:text-gray-300">1. KIF/KIFU ファイルを選択</label>
                <div class="flex items-center justify-center w-full">
                    <label for="dropzone-file" class="flex flex-col items-center justify-center w-full h-48 border-2 border-gray-300 dark:border-gray-600 border-dashed rounded-lg cursor-pointer bg-gray-50 dark:hover:bg-bray-800 dark:bg-gray-700 hover:bg-gray-100 dark:hover:border-gray-500 dark:hover:bg-gray-600 transition">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg class="w-10 h-10 mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-4-4V6a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7z"></path><path  stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m3-3H7"></path></svg>
                            <p class="mb-2 text-sm text-gray-500 dark:text-gray-400"><span class="font-semibold">クリックしてアップロード</span>またはドラッグ＆ドロップ</p>
                            <p class="text-xs text-gray-500 dark:text-gray-400">.kif または .kifu ファイル</p>
                            <p id="file-name" class="mt-2 text-sm font-semibold text-indigo-600 dark:text-indigo-400"></p>
                        </div>
                        <input id="dropzone-file" type="file" class="hidden" accept=".kif,.kifu">
                    </label>
                </div>
            </div>

            <div class="text-center mb-6">
                 <button id="convert-button" class="custom-button w-full md:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-lg shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed disabled:shadow-none" disabled>
                    変換実行
                </button>
            </div>

            <div id="error-display" class="hidden my-4 p-4 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-700 text-red-700 dark:text-red-200 rounded-lg">
                <h3 class="font-bold">エラーが発生しました</h3>
                <p id="error-message"></p>
            </div>

            <div id="result-container" class="hidden">
                <div class="flex justify-between items-center mb-2">
                     <h2 class="text-xl font-semibold text-gray-800 dark:text-white">変換結果 (SFEN)</h2>
                    <button id="copy-button" class="custom-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm">
                        全コピー
                    </button>
                </div>
                <textarea id="sfen-output" rows="15" class="w-full p-3 bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 font-mono text-sm" readonly></textarea>
                 <div id="copy-feedback" class="text-center mt-2 text-green-600 dark:text-green-400 font-medium opacity-0 transition-opacity duration-300">コピーしました！</div>
            </div>
        </main>
        
        <footer class="text-center mt-8 text-sm text-gray-500 dark:text-gray-400">
            <p>&copy; 2025 KIF to SFEN Converter. All rights reserved.</p>
        </footer>
    </div>

    <script>
        // --- 定数定義 ---
        const PIECES = {
            '歩': 'P', '香': 'L', '桂': 'N', '銀': 'S', '金': 'G', '角': 'B', '飛': 'R', '玉': 'K', '王': 'K',
            'と': '+P', '成香': '+L', '杏': '+L', '成桂': '+N', '圭': '+N', '成銀': '+S', '全': '+S', 
            '馬': '+B', '龍': '+R', '竜': '+R'
        };
        const KANJI_NUM = { '一': 1, '二': 2, '三': 3, '四': 4, '五': 5, '六': 6, '七': 7, '八': 8, '九': 9 };
        const ZENKAKU_NUM = { '１': 1, '２': 2, '３': 3, '４': 4, '５': 5, '６': 6, '７': 7, '８': 8, '９': 9 };
        const SFEN_HAND_ORDER = ['R', 'B', 'G', 'S', 'N', 'L', 'P'];

        // --- DOM要素 ---
        const fileInput = document.getElementById('dropzone-file');
        const fileNameDisplay = document.getElementById('file-name');
        const convertButton = document.getElementById('convert-button');
        const sfenOutput = document.getElementById('sfen-output');
        const errorDisplay = document.getElementById('error-display');
        const errorMessage = document.getElementById('error-message');
        const resultContainer = document.getElementById('result-container');
        const copyButton = document.getElementById('copy-button');
        const copyFeedback = document.getElementById('copy-feedback');

        let selectedFile = null;

        // --- ファイル選択イベント ---
        fileInput.addEventListener('change', (e) => {
            selectedFile = e.target.files[0];
            if (selectedFile) {
                fileNameDisplay.textContent = selectedFile.name;
                convertButton.disabled = false;
            } else {
                fileNameDisplay.textContent = '';
                convertButton.disabled = true;
            }
        });
        
        // --- ドラッグ＆ドロップ ---
        const dropzone = fileInput.parentElement;
        dropzone.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dark:border-indigo-500', 'border-indigo-500'); });
        dropzone.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dark:border-indigo-500', 'border-indigo-500'); });
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dark:border-indigo-500', 'border-indigo-500');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                fileInput.dispatchEvent(new Event('change'));
            }
        });

        // --- 変換ボタンイベント ---
        convertButton.addEventListener('click', () => {
            if (!selectedFile) return;
            hideError();
            resultContainer.classList.add('hidden');
            const encoding = selectedFile.name.toLowerCase().endsWith('.kifu') ? 'UTF-8' : 'Shift_JIS';
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const kifData = e.target.result;
                    const sfenList = processKif(kifData);
                    sfenOutput.value = sfenList.join('\n');
                    resultContainer.classList.remove('hidden');
                } catch (err) {
                    showError(err.message);
                    console.error(err);
                }
            };
            reader.onerror = () => { showError(`ファイルの読み込みに失敗しました。エンコーディングが'${encoding}'でない可能性があります。`); };
            reader.readAsText(selectedFile, encoding);
        });
        
        // --- コピーボタンイベント ---
        copyButton.addEventListener('click', () => {
            sfenOutput.select();
            document.execCommand('copy');
            sfenOutput.blur();
            copyFeedback.classList.remove('opacity-0');
            setTimeout(() => { copyFeedback.classList.add('opacity-0'); }, 2000);
        });

        // --- 将棋のロジック ---
        class ShogiGame {
            constructor() {
                this.initGame();
            }

            initGame() {
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.hands = { b: {}, w: {} }; // b: sente, w: gote
                this.turn = 'b';
                this.moveNumber = 1;
                this.lastMove = null;
                this.initBoardFromSfen();
            }
            
            // SFENの初期局面文字列から盤面を生成
            initBoardFromSfen(sfenBoard = 'lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL') {
                const rows = sfenBoard.split('/');
                for (let y = 0; y < 9; y++) {
                    let x = 0;
                    for (const char of rows[y]) {
                        if (char === '+') continue; // skip promoter
                        const nextChar = rows[y][rows[y].indexOf(char) + 1] || '';
                        const isPromoted = char === '+';

                        if (isNaN(parseInt(char))) {
                            let piece = char;
                             if(rows[y][rows[y].indexOf(char)-1] === '+') {
                                piece = '+' + piece;
                            }
                            this.board[y][x] = piece;
                            x++;
                        } else {
                            x += parseInt(char);
                        }
                    }
                }
            }
            
            toSfen() {
                let boardStr = '';
                for (let y = 0; y < 9; y++) {
                    let emptyCount = 0;
                    for (let x = 0; x < 9; x++) {
                        const piece = this.board[y][x];
                        if (piece) {
                            if (emptyCount > 0) {
                                boardStr += emptyCount;
                                emptyCount = 0;
                            }
                            boardStr += piece;
                        } else {
                            emptyCount++;
                        }
                    }
                    if (emptyCount > 0) { boardStr += emptyCount; }
                    if (y < 8) { boardStr += '/'; }
                }

                let handStr = '';
                for (const owner of ['b', 'w']) {
                    for (const piece of SFEN_HAND_ORDER) {
                        const hand = this.hands[owner];
                        if (hand[piece] > 0) {
                            if (hand[piece] > 1) { handStr += hand[piece]; }
                            handStr += (owner === 'b' ? piece : piece.toLowerCase());
                        }
                    }
                }
                if (handStr === '') { handStr = '-'; }

                return `${boardStr} ${this.turn} ${handStr} ${this.moveNumber}`;
            }

            applyKifMove(move) {
                const { piece, to, from, promote, isDrop } = this.parseKifMove(move);
                const toRow = to.y - 1;
                const toCol = 9 - to.x;
                const sfenPiece = PIECES[piece];
                if (!sfenPiece) { throw new Error(`指し手 ${this.moveNumber}: 未知の駒です: ${piece}`); }

                if (isDrop) {
                    if (this.board[toRow][toCol]) { throw new Error(`指し手 ${this.moveNumber}: ${to.x}${to.y} には既に駒があります (駒打ち)`); }
                    const hand = this.turn === 'b' ? this.hands.b : this.hands.w;
                    if (!hand[sfenPiece] || hand[sfenPiece] <= 0) { throw new Error(`指し手 ${this.moveNumber}: ${piece} の持ち駒がありません。`); }
                    hand[sfenPiece]--;
                    this.board[toRow][toCol] = this.turn === 'b' ? sfenPiece.toUpperCase() : sfenPiece.toLowerCase();
                } else {
                    const fromRow = from.y - 1;
                    const fromCol = 9 - from.x;
                    const movingPiece = this.board[fromRow][fromCol];
                    if (!movingPiece) { throw new Error(`指し手 ${this.moveNumber}: ${from.x}${from.y} に動かす駒がありません。`); }

                    const capturedPiece = this.board[toRow][toCol];
                    if (capturedPiece) { this.addPieceToHand(capturedPiece); }
                    
                    this.board[fromRow][fromCol] = null;
                    let newPiece = movingPiece;
                    if (promote && !movingPiece.startsWith('+')) {
                        newPiece = '+' + movingPiece.toUpperCase();
                        if (this.turn === 'w') newPiece = newPiece.toLowerCase();
                    }
                    this.board[toRow][toCol] = newPiece;
                }
                
                this.lastMove = { to: { x: to.x, y: to.y } };
                this.turn = (this.turn === 'b') ? 'w' : 'b';
                this.moveNumber++;
            }
            
            addPieceToHand(capturedPiece) {
                const unpromotedPiece = capturedPiece.replace('+', '').toUpperCase();
                const hand = this.turn === 'b' ? this.hands.b : this.hands.w;
                hand[unpromotedPiece] = (hand[unpromotedPiece] || 0) + 1;
            }

            parseKifMove(kifMoveStr) {
                const fullMoveStr = kifMoveStr.trim().split(/\s+/)[0];
                let to, from = null, piece, promote = false, isDrop = false;
                let remainingStr = fullMoveStr;

                const fromMatch = remainingStr.match(/\((\d{2})\)/);
                if (fromMatch) {
                    from = { x: parseInt(fromMatch[1][0]), y: parseInt(fromMatch[1][1]) };
                    remainingStr = remainingStr.replace(fromMatch[0], '');
                }

                if (remainingStr.endsWith('成')) { promote = true; remainingStr = remainingStr.slice(0, -1); }
                else if (remainingStr.endsWith('打')) { isDrop = true; remainingStr = remainingStr.slice(0, -1); }

                if (remainingStr.startsWith('同')) {
                    if (!this.lastMove) throw new Error("初手で '同' は使えません。");
                    to = { ...this.lastMove.to };
                    piece = remainingStr.slice(1).trim();
                } else {
                    const coordStr = remainingStr.slice(0, 2);
                    piece = remainingStr.slice(2).trim();
                    if(!ZENKAKU_NUM[coordStr[0]] || !KANJI_NUM[coordStr[1]]) { throw new Error(`指し手 ${this.moveNumber}: 不正な座標です: ${coordStr}`); }
                    to = { x: ZENKAKU_NUM[coordStr[0]], y: KANJI_NUM[coordStr[1]] };
                }

                if (piece === '竜') piece = '龍';
                if (['と', '杏', '圭', '全', '馬', '龍'].includes(piece)) {
                    promote = true;
                    const sfenPromoted = PIECES[piece];
                    const sfenUnpromoted = sfenPromoted.replace('+', '');
                    const kanjiUnpromoted = Object.keys(PIECES).find(k => PIECES[k] === sfenUnpromoted && k.length === 1);
                    piece = kanjiUnpromoted || piece;
                }
                
                if (!from && !isDrop) {
                    from = this.findSource(piece, to);
                    if (!from) {
                        const KANJI_NUM_REV = Object.fromEntries(Object.entries(KANJI_NUM).map(([k, v]) => [v, k]));
                        throw new Error(`指し手 ${this.moveNumber}: ${piece} を ${to.x}${KANJI_NUM_REV[to.y]} へ動かす駒が見つかりません。`);
                    }
                }
                return { piece, to, from, promote, isDrop };
            }
            
            findSource(pieceKanji, to) {
                const sfenPieceType = PIECES[pieceKanji];
                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        const boardPiece = this.board[y][x];
                        if (!boardPiece) continue;
                        const pieceOwner = (boardPiece.toLowerCase() === boardPiece) ? 'w' : 'b';
                        if (this.turn === pieceOwner && boardPiece.toUpperCase().replace('+', '') === sfenPieceType) {
                            // TODO: 厳密な合法手判定。現在は最初に見つかったものを返す。
                            return { x: 9 - x, y: y + 1 };
                        }
                    }
                }
                return null;
            }
        }

        // --- KIF処理のメイン関数 ---
        function processKif(kifData) {
            const game = new ShogiGame();
            const sfenList = [];
            // TODO: 手合割に応じて初期局面を変更する処理
            
            sfenList.push(game.toSfen()); // 初期局面を追加

            const lines = kifData.split(/\r\n|\n|\r/);
            const moveRegex = /^\s*\d+\s+/;
            
            for (const line of lines) {
                if (line.startsWith('*') || line.startsWith('手数----') || line.trim() === '' || line.includes('：')) {
                    continue;
                }
                
                if (moveRegex.test(line)) {
                    const moveStr = line.replace(moveRegex, '').trim();
                     if (moveStr.includes('投了') || moveStr.includes('中断') || moveStr.includes('詰み') || moveStr.includes('千日手')) {
                        break;
                    }
                    game.applyKifMove(moveStr);
                    sfenList.push(game.toSfen());
                }
            }
            return sfenList;
        }
        
        // --- UI補助関数 ---
        function showError(message) { errorMessage.textContent = message; errorDisplay.classList.remove('hidden'); }
        function hideError() { errorDisplay.classList.add('hidden'); }
    </script>
</body>
</html>
